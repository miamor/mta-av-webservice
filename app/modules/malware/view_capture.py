from flask_restplus import Resource
from app.modules.common.decorator import token_required, admin_token_required
# from .capture import Capture
from .dto_capture import DtoCapture
from .controller_capture import ControllerCapture
from flask import request, jsonify, abort
from werkzeug.utils import secure_filename
import os
import app.settings.cf as cf
# from werkzeug.datastructures import FileStorage
from ..detector.detection_module import Detector
from app.utils.response import error, result
from flask_restplus import marshal
import time
import datetime

import threading
import concurrent.futures

api = DtoCapture.api
capture = DtoCapture.model


@api.route('')
class CaptureList(Resource):
    @api.marshal_list_with(capture)
    def get(self):
        data = request.args
        mode = int(data['mode']) if 'mode' in data else 0
        print('mode = ', mode)
        controller = ControllerCapture()
        return controller.get(mode)

    @api.expect(capture)
    @api.marshal_with(capture)
    def post(self):
        # data = api.payload
        # data = request.form.to_dict(flat=True)
        data = request.get_json()
        print('data post METHOD~~~~', data)
        controller = ControllerCapture()
        return controller.create(data=data)


@api.route('/check')
class CaptureCheck(Resource):
    # @api.marshal_with(capture)
    def post(self):
        print('request.files', request.files)
        print('request.remote_addr', request.remote_addr)
        print('request.form', request.form)

        post_data = request.form.to_dict(flat=False)
        print('post_data', post_data)
        task_data = []
        for i in range(len(post_data['destination_ip'])):
            tmp = {}
            for field in post_data:
                tmp[field] = post_data[field][i]
            task_data.append(tmp)
        print('** task_data', task_data)

        # check if the post request has the file part
        if 'files[]' not in request.files:
            resp = jsonify(
                {"status": "error", "status_msg": "No file part in the request"})
            resp.status_code = 400
            return resp

        files = request.files.getlist('files[]')

        task_ids = []
        filenames = []
        filepaths = []
        for i in range(len(files)):
            file = files[i]

            if file.filename == "":
                continue

            # if file and allowed_file(file.filename):
            if file:
                filename = secure_filename(file.filename)
                filepath = os.path.join(cf.UPLOAD_FOLDER, filename)
                file.save(filepath)

                filenames.append(filename)
                filepaths.append(filepath)


        detector = Detector()
        # Run sandbox
        task_ids, resp, scan_time = detector.run(filenames, filepaths)

        # start a thread for other detectors
        # t1 = threading.Thread(target=detector.run_han, args=(task_ids))
        # t1.start()
        with concurrent.futures.ThreadPoolExecutor() as executor:
            print('resp', resp)
            future_han = executor.submit(detector.run_han, task_ids, resp)
            resp_all, scan_time = future_han.result()
            print('** HAN return ', resp_all, scan_time)

            future_ngram = executor.submit(detector.run_ngram, filepaths, task_ids, resp_all)
            resp_all, scan_time = future_ngram.result()
            print('** NGRAM return ', resp_all, scan_time)
            
            for i in range(len(files)):
                task_id = task_ids[i]
                filename = filenames[i]
                filepath = filepaths[i]
                res = resp_all[0][task_id]
                engines_detected = resp_all[1][task_id]
                print('res', res)
                # if res['is_malware'] == 1:
                print('i=', i, task_data[i])
                if True:
                    task_data[i]['file_name'] = filename
                    task_data[i]['file_size'] = os.path.getsize(filepath)
                    task_data[i]['file_extension'] = filepath.split('.')[-1]
                    task_data[i]['file_path'] = filepath
                    task_data[i]['report_path'] = res['report_path']
                    task_data[i]['report_id'] = res['report_id']

                    task_data[i]['hash'] = res['hash_value']
                    task_data[i]['md5'] = res['md5']
                    task_data[i]['sha1'] = res['sha1']
                    task_data[i]['sha256'] = res['sha256']
                    task_data[i]['sha512'] = res['sha512']
                    task_data[i]['ssdeep'] = res['ssdeep']

                    # task_data[i]['source_ip'] = request.remote_addr
                    task_data[i]['detected_by'] = ','.join(engines_detected)
                    task_data[i]['scan_time'] = scan_time
                    task_data[i]['date_received'] = time.strftime('%Y-%m-%d')
                    task_data[i]['time_received'] = time.strftime('%H:%M:%S')

                    print('**** data insert: ', task_data[i])
                    controller = ControllerCapture()
                    malware = controller.create(data=task_data[i])
                    print('**** malware inserted', i, malware)
                # else:
                #     return result(message='Check completed. File clean!', data=resp_all[0][task_id])

            return result(message='Check completed', data=resp_all[0])

        # print('resp', resp)
        # return result(message='Check completed. File clean!')


@api.route('/download_file')
class CaptureDownload(Resource):
    # @api.marshal_with(capture)
    def get(self):
        path = '/home/mtaav/CODE/mta-av-webservice/Update'
        lstFile = os.listdir(path)
        date = str(datetime.datetime.now().strftime('%d-%m-%Y'))
        for item in lstFile:
            # print(item.split('.')[0])
            if (date == item.split('.')[0]):
                return send_file(os.path.join(path, item), as_attachment=True)
        abort(404, 'not available')


@api.route('/<int:cid>')
class Capture(Resource):
    @api.marshal_with(capture)
    def get(self, cid):
        controller = ControllerCapture()
        return controller.get_by_id(object_id=cid)

    # @api.expect(capture)
    # def put(self, cid):
    #     data = api.payload
    #     controller = ControllerCapture()
    #     return controller.update(object_id=cid, data=data)

    def delete(self, cid):
        controller = ControllerCapture()
        return controller.delete(object_id=cid)


@api.route('/report/<int:report_id>')
class CaptureReport(Resource):
    def get(self, report_id):
        controller = ControllerCapture()
        return controller.get_report_by_id(report_id=report_id)


@api.route('/stat')
class CaptureStat(Resource):
    def get(self):
        controller = ControllerCapture()
        # mal_num, ip_mal_num, stat_by_date, top_ip_mal, top_ip_send, top_ip_rev_mal = controller.stat()
        mal_num, bgn_num, ip_mal_num, charts = controller.stat()
        resp = jsonify({
            "status": "success",
            "malwares_num": mal_num,
            "benigns_num": bgn_num,
            "ip_malwares_num": ip_mal_num,
            # "stat_by_date": stat_by_date,
            # "top_ip_mal": top_ip_mal,
            # "top_ip_send": top_ip_send,
            # "top_ip_rev_mal": top_ip_rev_mal
            "charts": charts
        })
        resp.status_code = 200
        return resp


@api.route('/search/<string:capture_hash>')
class CaptureSearchHash(Resource):
    @api.marshal_with(capture)
    def get(self, capture_hash):
        controller = ControllerCapture()
        return controller.get_by_hash(object_hash=capture_hash)

#     @api.expect(capture)
#     def put(self, capture_hash):
#         data = api.payload
#         controller = ControllerCapture()
#         return controller.update(object_hash=capture_hash, data=data)

#     def delete(self, capture_hash):
#         controller = ControllerCapture()
#         return controller.delete(object_hash=capture_hash)
